
## Завдання:
3 завдання

**Генерувати абсолютно випадкове число від 1 до 100 без використання генераторів випадкових чисел.**

### Огляд:

Цей скрипт написано для конкурсу, де мета - створити найгірше однорядкове рішення для задачі, що вимагає генерувати випадкове число від 1 до 100 без безпосереднього використання стандартних генераторів випадкових чисел.
Основний код, для участі в конкурсі - `main.py`

### Як це працює:

1.  **LCG (Лінійний Конгруентний Генератор)**: Скрипт включає реалізацію простого LCG (лінійного конгруентного генератора). Це псевдовипадковий генератор чисел, але тут ми не використовуємо модуль `random` Python, тому це допустимо!
    
2.  **Шум на основі часу**: Функція `gn()` використовує поточний час у мілісекундах (отриманий за допомогою `time.time()`), множачи його на 1000, щоб змоделювати випадковість за допомогою системного годинника. Це значення потім ділиться на 100, щоб створити "випадкове" насіння від 0 до 99.
    
3.  **Генерація випадкових чисел**: Функція `gnum(n)` повертає список згенерованих чисел, використовуючи LCG, і змінює генератор кожні 10 ітерацій. Якщо поточний індекс `i` ділиться на 10, LCG скидається з новим насінням від `gn()`.
    
4.  **Трансформація чисел**: Функція `tnum(n)` приймає список згенерованих чисел і модифікує їх на основі їх індекса. Для кожного 15-го числа додається 10, а для кожного 20-го числа віднімається 5, але гарантовано, що значення не зменшиться нижче 0, використовуючи `max(0, x-5)`.
    
5.  **Фінальний Результат**: Скрипт виводить 4-й елемент з модифікованого списку, згенерованого `tnum(gnum(10))`.
    

----------

### Інструкція з запуску:

1.  Переконайтеся, що у вас встановлений Python (версія 3.6 або новіша).
2.  Скопіюйте код скрипта в файл з ім'ям `main.py`.
3.  Відкрийте термінал або командний рядок.
4.  Перейдіть до директорії, де збережено файл `main.py`.
5.  Запустіть скрипт командою:

    `python main.py` 
    
_______
###  Що зробив я, для погрішення коду

В альтернативному коді все набагато «складніше».

1.  **Змішування мов**: Змінні та вбудовані функції перейменовуються з використанням символів з різних мов, таких як японська (наприклад, `時間`, `時刻`), корейська (наприклад, `ㄱㄴ`, `ㄷㄹㅁㅂ`), хінді (наприклад, `लिस्ट_बनाओ`) та іврит (наприклад, `רשימה_מעובדת`). Це вносить непотрібну складність і плутанину.  
    
2.  **Вбудоване перевизначення**: У другій версії перевизначено багато вбудованих функцій Python, що використовують різні мови. Наприклад, `max()` стає `मैक्स`, `print()` стає `imprimer`, а `int()` стає `整数`. Ці імена не мають сенсу для пересічного читача, що робить код більш складним для розуміння.  
    
3.  **LCG та часова логіка**: Основна логіка залишається тією ж самою, з LCG для генерації псевдовипадкових чисел і системним годинником як «випадковим» початковим значенням, але з ще більшим заплутуванням. Наприклад, `gn()` стає `ㄱㄴ()`, а генератор LCG - `ㄷㄹㅁㅂ()`.  
    
4.  **Потік виконання**: Логіка перетворення подібна до оригіналу, але читабельність коду була навмисно зіпсована. Наприклад, для додавання та віднімання значень зі списку використовуються зайві функції (`جمع` та `引き算`) замість простих операторів.

----------
### Як виглядає погрішена версія `test.py`
![image](https://github.com/user-attachments/assets/4b063721-c26c-4efa-bea7-9d6d5000b94e)
### Пояснення коду `test3.py`:

	import pyperclip

	def print_file_contents(filename):
    code = ''
    with open(filename, 'r', encoding='utf-8') as f:
        for line in f:
            line = line.replace('\n', '\\n').replace('\t', '\\t')
            code += line
    return code

	code = print_file_contents('test2.py')
	pyperclip.copy(code)

	
#### Що робить цей код:

1.  **Імпорт бібліотеки**: Код імпортує бібліотеку `pyperclip`, яка дозволяє копіювати текст у буфер обміну.
2.  **Функція `print_file_contents(filename)`**:
    -   Відкриває файл з вказаним ім'ям (`filename`) у режимі читання з кодуванням `utf-8`.
    -   Читає вміст файлу, рядок за рядком.
    -   Заміщує символи нового рядка (`\n`) і табуляції (`\t`) відповідними екранізованими значеннями (`\\n` і `\\t`), щоб зберегти їх у текстовій формі.
    -   Додає кожен модифікований рядок до змінної `code`.
3.  **Копіювання вмісту у буфер обміну**:
    -   Викликає функцію `print_file_contents` з ім'ям файлу `test2.py`, отримує вміст цього файлу, а потім копіює отриманий код у буфер обміну за допомогою `pyperclip.copy(code)`.
 4.  **Якщо коротко**:
	 - Копіює код, для того щоб його можно було вставити в одну строку, за допомогою `exec`
